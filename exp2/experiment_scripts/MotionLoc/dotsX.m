function [frames, rseed, start_time, end_time, response, response_time] = dotsX(screenInfo, dotInfo, targets, blockLength, trialstart,count)%% [frames, rseed, start_time, end_time, response, response_time] =% dotsX(screenInfo, dotInfo, targets)% targets optional.%% arguments - minimum fields for dotInfo and screenInfo - see createDotInfo% and openExperiment%%   most everything is in visual degrees * 10, since rex only likes integers %%       dotInfo.numDotField     number of dot patches that will be shown on the screen%		dotInfo.coh             vertical vectors, dots coherence (0...999) for each dot patch%		dotInfo.speed           vertical vectors, dots speed (10th deg/sec) for each dot patch%		dotInfo.dir             vertical vectors, dots direction (degrees) for each dot patch%       dotInfo.dotSize         size of dots in pixels, same for all patches%       dotInfo.dotColor        color of dots in rgb, same for all patches%       dotInfo.maxDotsPerFrame determined by testing video card%       dotInfo.apXYD           x, y coordinates, and diameter of aperture(s) in visual degrees          %		dotInfo.maxDotTime2      optional, can set maximum duration (sec).%		                        if not, dot presentation terminated only by user response%       dotInfo.trialtype       1 fixed duration, 2 reaction time%       dotInfo.keys            a set of keyboard buttons that can%                               terminate the presentation of dots (optional)%       dotInfo.mouse           a set of mouse buttons that can terminate%                               the presentation of dots (optional)%%       screenInfo.curWindow    window on which to plot dots%       screenInfo.center       center of the screen in pixels%       screenInfo.ppd          pixels per visual degree%       screenInfo.monRefresh   monitor refresh value%       screenInfo.dontclear    If set to 1, flip will not clear the framebuffer after Flip - this allows incremental %                               drawing of stimuli. Needs to be zero for dots to be erased.%		screenInfo.rseed        random # seed, can be empty set[] %%       targets structure not necessary if not showing targets with the%       dots%       targets.rects   dimensions for drawOval%       targets.colors  color of targets%       targets.show    optional, if only showing certain targets but don't%            want to change targets structure (index number of target(s) to be%            shown during dots%% algorithm:%		All calculations take place within a square aperture% in which the dots are shown. The dots are constructed in 3 sets that are% plotted in sequence.  For each set, the probability that a dot is% replotted in motion -- as opposed to randomly replaced -- is given by the% dotInfo.coh value.  This routine generates a set of dots as an ndots_ by% 2 matrix of locations, and then plots them.  In plotting the next set of% dots (e.g., set 2) it prepends the preceding set (e.g., set 1).%% created by MKMK July 2006, based on ShadlenDots by MNS, JIG and others% structures are not altered in this function, so should not have memory% problems from matlab creating new structures...% CURRENTLY THERE IS AN ALMOST ONE SECOND DELAY FROM THE TIME DOTSX IS% CALLED UNTIL THE DOTS START ON THE SCREEN! THIS IS BECAUSE OF %priority.% NEED TO EVALUATE WHETHER %priority IS REALLY NECESSARY.%if nargin < 3    targets = [];    showtar = [];else    if isfield(targets,'show')        showtar = targets.show;    else        showtar = 1:size(targets.rects,1);    endendcurWindow = screenInfo.curWindow;dotColor = dotInfo.dotColor;rseed = screenInfo.rseed;% this only matters if using mouse, if dotInfo.mouse doesn't exist, this is% never checked.if dotInfo.trialtype(2) == 2    waitpress = 1; % 1 means wait for a mouse presselse    waitpress = 0; % 0 means wait for releaseend% to find out if using keypress or mouse, all trials should have spacekey% for abort, unless its a demo.% spacekey to abortkeys = [];abort = [];if isfield(dotInfo, 'keyLeft')    keys = [dotInfo.keyLeft dotInfo.keyRight];elseif isfield(dotInfo, 'keySpace')    abort = nan;end% mouseif isfield(dotInfo, 'mouse')    mouse = dotInfo.mouse;else    mouse = [];endstart_time = NaN;end_time= NaN;response = {NaN, NaN NaN};response_time = NaN;if isfield(targets,'select')    h = targets.select(:,1);    k = targets.select(:,2);    r = targets.select(:,3);end% SEED THE RANDOM NUMBER GENERATOR ... if "[]" is given, reset% the seed "randomly"... this is for VAR/NOVAR conditionsif ~isempty(rseed) && length(rseed) == 1    rand('state', rseed);elseif ~isempty(rseed) && length(rseed) == 2    rand('state', rseed(1)*rseed(2));else    rseed = sum(100*clock);    rand('state', rseed);end% create the square for the apertureapRect = floor(createTRect(dotInfo.apXYD, screenInfo));apRectLarge = floor(createTRect([1 1 1.25].*dotInfo.apXYD, screenInfo)); %cer% USEFUL LOCAL VARS% variables that are sent to rex have been multiplied by a factor of 10 to% make sure they are integers. Now we have to convert them back so that% they are correct for plotting.coh   	= dotInfo.coh/1000;	%  % dotInfo.coh is specified on 0... (because% of rex needing integers), but we want 0..1apD = dotInfo.apXYD(:,3); % diameter of aperturesize(screenInfo.center);center = repmat(screenInfo.center,size(dotInfo.apXYD(:,1)));size(dotInfo.apXYD(:,1:2));% change the xy coordinates to pixels (y is inverted - pos on bottom, neg.% on topcenter = [center(:,1) + dotInfo.apXYD(:,1)/10*screenInfo.ppd center(:,2) - dotInfo.apXYD(:,2)/10*screenInfo.ppd]; % where you want the center of the apertured_ppd 	= floor(apD/10 * screenInfo.ppd);	% size of aperture in pixelsdotSize = dotInfo.dotSize; % probably better to leave this in pixels, but not sure%dotSize = screenInfo.ppd*dotInfo.dotSize/10;% ndots is the number of dots shown per video frame% we will place dots in a square the size of the aperture% - Size of aperture = Apd*Apd/100  sq deg% - Number of dots per video frame = 16.7 dots per sq.deg/sec,%        Round up, do not exceed the number of dots that can be%		 plotted in a video frame (dotInfo.maxDotsPerFrame)% maxDotsPerFrame was originally in setupScreen as a field in screenInfo,% but makes more sense in createDotInfo as a field in dotInfondots 	= min(dotInfo.maxDotsPerFrame, ceil(16.7 * apD .* apD * 0.01 / screenInfo.monRefresh));ndots = 50; %CER%disp('after one loop')% loop length is determined by the field "dotInfo.maxDotTime2"% if none given, loop until "continue_show=0" is set by other means (eg% user response), otherwise loop until dotInfo.maxDotTime2% always one video frame per loop%Caroline changed here all "maxDotTime" to "maxDotTime2" then use dotInfo.maxDotTime2 to set maximum dot durationif ~isfield(dotInfo,'maxDotTime2') || (isempty(dotInfo.maxDotTime2) && ndots>0),    continue_show = -1;elseif ndots > 0,    continue_show = round(dotInfo.maxDotTime2*screenInfo.monRefresh);else    continue_show = 0;end;dontclear = screenInfo.dontclear;% THE MAIN LOOPframes = 0;%priorityLevel = Max%priority(curWindow,'KbCheck');%priority(%priorityLevel);index = 0;% make sure the fixation still onfor i = showtar    Screen('FillOval', screenInfo.curWindow, targets.colors(i,:), targets.rects(i,:));endScreen('DrawingFinished',screenInfo.curWindow,dontclear);% how dots are presented: 1 group of dots are shown in the first frame, a% second group are shown in the second frame, a third group shown in the% third frame, then in the next frame, some percentage of the dots from the% first frame are replotted according to the speed/direction and coherence,% the next frame the same is done for the second group, etc.%GetSecs - testfor df = 1 : dotInfo.numDotField,    ss{df}		= rand(ndots(df)*3, 2); % array of dot positions raw [xposition yposition]    % divide dots into three sets...    Ls{df}      = cumsum(ones(ndots(df),3))+repmat([0 ndots(df) ndots(df)*2], ndots(df), 1);    loopi(df)   = 1; 	% loops through the three sets of dotsend;%% set up catch trials where fixation dimsinstructionType = 0; %localizing motor cortex with rhythmic button presses every second?lengthcatch = 0.175; %fixation dims%lengthcatch = 0; %fixation dimsif instructionType == 0    firstcatch = GetSecs + 1; %cannot occur in the first (or last) second of the block    lengthcatch = 0.175; %fixation dims    catchtimes = (firstcatch+dotInfo.maxDotTime2 - 1 - firstcatch).*rand([1,3]) + firstcatch; %three catch trials, lasting for lengthcatch    catchtimes = [catchtimes;catchtimes+lengthcatch];else    firstcatch = GetSecs + 1; %cannot occur in the first (or last) second of the block    catchtimes = (firstcatch+dotInfo.maxDotTime2 - 1 - firstcatch).*rand([1,3]) + firstcatch; %three catch trials, lasting for lengthcatch    catchtimes = [catchtimes;catchtimes+lengthcatch];end%% start dot loopstart = GetSecs;Randdirections = 0:12:360;Randdirections = Randdirections(randperm(length(Randdirections)));while GetSecs-trialstart < blockLength %continue_show						    for df = 1 : dotInfo.numDotField,                                clear dxdy{df}                                for index = 1:round(blockLength) % length of block = 12s                                    if (GetSecs-start)<index                                        dotInfo.dir=Randdirections(index);    									% dxdy is an N x 2 matrix that gives jumpsize in units on 0..1     									%    	 deg/sec     * Ap-unit/deg  * sec/jump   =   unit/jump                                        dxdy{df} 	= repmat((dotInfo.speed(df)/10) * (10/apD(df)) * (3/screenInfo.monRefresh) *[cos(pi*dotInfo.dir(df)/180.0) -sin(pi*dotInfo.dir(df)/180.0)], ndots(df),1);                                        break                                    end                                end                                								if (GetSecs-start)>round(blockLength)									start=GetSecs;								end;        % ss is the matrix with the 3 sets of dot positions, dots from the last 2 positions + current        % Ls picks out the set (for ex., with 5 dots on the screen at a time, 1:5, 6:10, or 11:15)        Lthis{df}  = Ls{df}(:,loopi(df));  % Lthis now has the dot positions from 3 frames ago, which is what is then        % moved in the current loop        this_s{df} = ss{df}(Lthis{df},:); % this is a matrix of random #s - starting positions for dots not moving coherently                % update the loop pointer        loopi(df) = loopi(df)+1;        if loopi(df) == 4,            loopi(df) = 1;        end        % compute new locations, how many dots move coherently        L = rand(ndots(df),1) < coh(df);        this_s{df}(L,:) = this_s{df}(L,:) + dxdy{df}(L,:);	% offset the selected dots        if sum(~L) > 0            this_s{df}(~L,:) = rand(sum(~L),2);	    % get new random locations for the rest        end        % wrap around - check to see if any positions are greater than one or less than zero        % which is out of the square aperture, and then replace with a dot along one        % of the edges opposite from direction of motion.        N = sum((this_s{df} > 1 | this_s{df} < 0)')' ~= 0;        if sum(N) > 0            xdir = sin(pi*dotInfo.dir(df)/180.0);            ydir = cos(pi*dotInfo.dir(df)/180.0);            % flip a weighted coin to see which edge to put the replaced            % dots            if rand < abs(xdir)/(abs(xdir) + abs(ydir))                this_s{df}(find(N==1),:) = [rand(sum(N),1) (xdir > 0)*ones(sum(N),1)];            else                this_s{df}(find(N==1),:) = [(ydir < 0)*ones(sum(N),1) rand(sum(N),1)];            end        end        % convert to stuff we can actually plot        this_x{df} = floor(d_ppd(df) * this_s{df});	% pix/ApUnit                % this assumes that zero is at the top left, but we want it to be        % in the center, so shift the dots up and left, which just means        % adding half of the aperture size to both the x and y direction.        dot_show{df} = (this_x{df} - d_ppd(df)/2)';    end;    % after all computations, flip, this draws dots from previous loop,    % first time through doesn't do anything    Screen('Flip', curWindow,0,dontclear);    % setup the mask - we will only be able to see a circular aperture,    % although dots moving in a square aperture. Minimizes the edge    % effects.    Screen('BlendFunction', curWindow, GL_ONE, GL_ZERO);    % want targets to still show up    Screen('FillRect', curWindow, [0 0 0 255]);    for df = 1 : dotInfo.numDotField,        % circle that frames the circle dots show up in        %Screen('FrameOval', curWindow, [255 0 0 255], apRectLarge(df,:), 135); %cerediting        % square that dots do not show up in (enlarged to prevent wrapping)        Screen('FillRect', curWindow, [0 0 0 0], apRectLarge(df,:), 10);        % circle that dots do show up in        Screen('FillOval', curWindow, [0 0 0 255], apRect(df,:), 10);     end        Screen('BlendFunction', curWindow, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA);    % now do actual drawing commands, although nothing drawn until next    % loop dots    for df = 1:dotInfo.numDotField        %Screen('DrawDots', curWindow, dot_show{df}, dotSize, dotColor, center(df,:));        Screen('DrawDots', curWindow, dot_show{df}, dotSize, dotColor, center(df,:),2); %circles instead of squares    end;    % targets    GetSecs;    catchtimes;    for i = showtar        if instructionType == 1 && mod(count,2) && (GetSecs < catchtimes(2,1) && GetSecs > catchtimes(1,1) || GetSecs < catchtimes(2,2) && GetSecs > catchtimes(1,2) || GetSecs < catchtimes(2,3) && GetSecs > catchtimes(1,3) || GetSecs < catchtimes(2,4) && GetSecs > catchtimes(1,4) || GetSecs < catchtimes(2,5) && GetSecs > catchtimes(1,5) || GetSecs < catchtimes(2,6) && GetSecs > catchtimes(1,6) || GetSecs < catchtimes(2,7) && GetSecs > catchtimes(1,7) || GetSecs < catchtimes(2,8) && GetSecs > catchtimes(1,8) || GetSecs < catchtimes(2,9) && GetSecs > catchtimes(1,9) || GetSecs < catchtimes(2,10) && GetSecs > catchtimes(1,10))            Screen('FillOval', screenInfo.curWindow, 0.25*targets.colors(i,:), targets.rects(i,:));        elseif instructionType == 0 && mod(count,2) && (GetSecs < catchtimes(2,1) && GetSecs > catchtimes(1,1) || GetSecs < catchtimes(2,2) && GetSecs > catchtimes(1,2) || GetSecs < catchtimes(2,3) && GetSecs > catchtimes(1,3))            Screen('FillOval', screenInfo.curWindow, 0.25*targets.colors(i,:), targets.rects(i,:));        else            Screen('FillOval', screenInfo.curWindow, targets.colors(i,:), targets.rects(i,:));        end        % circle that frames the circle dots show up in (gets rid of last wrapping effects)        %Screen('FrameOval', curWindow, [255 0 0 255], apRectLarge(df,:), 135); %cer     end     % tell ptb to get ready while doing computations for next dots presentation    Screen('DrawingFinished',curWindow,dontclear);    Screen('BlendFunction', curWindow, GL_ONE, GL_ZERO);    frames = frames + 1;        if frames == 1,     start_time = GetSecs;       end;    for df = 1 : dotInfo.numDotField,        % update the dot position array for the next loop        ss{df}(Lthis{df}, :) = this_s{df};    end;    % check for end of loop    continue_show = continue_show - 1;    if ~isempty(keys),        [keyIsDown,secs,keyCode] = KbCheck;        if keyIsDown,            % send abort signal            if keyCode(abort)                response{1} = find(keyCode(abort))            end        end;    end;    if ~isempty(mouse),        [x,y,buttons] = GetMouse(curWindow);        % check = 0 means exit dots, check = 1 means continue showing dots        check = 0;        if buttons            % mouse was pressed, if hold is on, and we know fixation            % position, make sure holding correct place             if waitpress == 0                if isfield(targets,'select')                    check = checkPosition(x,y,h(1),k(1),r(1));                end            else                % if hold is not on, and this is fixed duration, we don't                % care if the subject touches the screen - if reaction                % time, then touching means exit dots                if dotInfo.trialtype(1) == 1                    check = 1;                end            end            else            % mouse was not pressed.            % if waiting for a mouse press, continue paradigm            if waitpress == 1                check = 1;            end        end        if ~check            % for fixed duration, exiting early is always an error.            if dotInfo.trialtype(1) == 1                response{2} = 0;            else                % buttons is zero if we are doing reaction time where the                % subject has to hold during fixation, and releasing the                % mouse signifies end of the dots, otherwise should tell                % you the xy position. Eventually, I guess we should make                % it so we can use two mouse buttons as the answer...                if buttons                    response{2} = [x y];                    %response{2} = find(buttons(mouse));                else                    response{2} = 0;                end            end            response_time = GetSecs;            continue_show = 0;        end;    endend% present last frame of dotsScreen('Flip', curWindow,0,dontclear);% erase last dots, but leave up fixation and targets (if targets are up)% make sure the fixation still onshowTargets(screenInfo, targets, showtar);%showtarend_time = GetSecs;%priority(0);